Input:
    1 line, no leading or trailing whitespace, 
    Parent: (parent, child)
    All values are single uppercase letters
    Parent-Child pairs are seperated by a single space
    Sequence of pairs not ordered

Output:
    1 line
    No whitespace
    No errors, print S-expression
    Errors, print numerically first error

Errors:
    E1: Invalid input
    E2: Duplicate pair
    E3: Parent has more than two children
    E4: Multiple roots
    E5: Input contains cycle

PRINT NODES
//Print nodes
    for (int i = 0; i < nodes_occupied; i++) {
        cout << "Name: " << nodes[i].name << endl;
        cout << "Children: " <<  nodes[i].num_children() << endl;
        if (nodes[i].num_children() > 0) {
            node *c1 = nodes[i].child1;
            cout << "Child 1: " << c1->name << endl;
        }
        if (nodes[i].num_children() > 1) {
            node *c2 = nodes[i].child2;
            cout << "Child 2: " << c2->name << endl;
        }
        if ( nodes[i].parent != nullptr) {
            node *p = nodes[i].parent;
            cout << "Parent: " << p->name << endl;
        }
    }

PARSING
//Read in nodes and validate formatting
    while (!cin.fail()) {
        if (error == "") {
            string tree_str;
            cin >> tree_str;
            if (tree_str == "")
                break;
            if (!valid_str(tree_str)) {
                error = "E1";
            } else {
                nodes_strs.push_back(tree_str);
            }
        }
    }

    //Print out vector of nodes
    for (string i: nodes_strs) {
        cout << i << endl;
    }


    if (error == "")
        //Print s-expression
        cout << "S-Expression";
    else
        cout << error;

    return 0;
}

bool valid_str(string &str) {
    if (str.length() != 5)
        return false;
    if ((str[0] != '(') || (str[2] != ',') || (str[4] != ')'))
        return false;
    char parent = str[1];
    char child = str[3];

    if ((int)parent < 65 || (int)parent > 90 || (int)child < 65 || (int)child > 90)
        return false;
 
    string parsed = "";
    parsed.push_back(parent);
    parsed.push_back(child);
    str = parsed;
    
    return true;
}


#Through error 3
struct node {
    string name;
    node *parent;
    node *child1;
    node *child2;
    int num_children() {
        if (child2 == nullptr)
            return 1;
        else
            return 2;
    }
    bool has_parent() {
        if (parent == nullptr)
            return false;
        else
            return true;
    }
};

bool valid_str(string &str);
bool nodify(vector<node> &nodes, string str);

int main() {
    vector<string> node_strs;
    string error = "";

    //Read in nodes and validate formatting
    while (!cin.fail()) {
        if (error == "") {
            string tree_str;
            cin >> tree_str;
            if (tree_str == "")
                break;
            cout << "Preparsed str: " << tree_str << endl;
            if (!valid_str(tree_str)) {
                error = "E1";
            } else {
                node_strs.push_back(tree_str);
            }
        }
    }

    //Print out vector of nodes
    for (string i: node_strs) {
        cout << i << endl;
    }
    
    //Check for duplicates
    set<string> node_set(node_strs.begin(), node_strs.end());
    if (node_set.size() != node_strs.size())
        error = "E2";


    //Turn strings into nodes
    vector<node> nodes;
    for (int i = 0; i < node_strs.size(); i++) {
        if (error == "") {
            if (!nodify(nodes, node_strs.at(i)))
                error = "E3";
        }
    }


    if (error == "")
        //Print s-expression
        cout << "S-Expression";
    else
        cout << error;

    return 0;
}

bool valid_str(string &str) {
    if (str.length() != 5)
        return false;
    if ((str[0] != '(') || (str[2] != ',') || (str[4] != ')'))
        return false;
    char parent = str[1];
    char child = str[3];

    if ((int)parent < 65 || (int)parent > 90 || (int)child < 65 || (int)child > 90)
        return false;
 
    string parsed = "";
    parsed.push_back(parent);
    parsed.push_back(child);
    str = parsed;
    
    return true;
}

bool nodify(vector<node> &nodes, string str) {
    return true;
}